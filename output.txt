<file_overview>
Total files: 4
Date generated: 2024-09-15 21:08:04
Folder Structure:
├── AsyncOperation.h
├── CallbackDispatcher.h
├── main.cpp
└── ThreadPool.h

Files included:
- AsyncOperation.h
- CallbackDispatcher.h
- ThreadPool.h
- main.cpp
</file_overview>

<file path="AsyncOperation.h" lines="110" modified="2024-09-15 21:06:21">
//
// Created by maxim on 15.09.2024.
//
#pragma once

#include <iostream>

#include "ThreadPool.h"
#include "CallbackDispatcher.h"


template<typename T>
class AsyncExecutor {
public:
    using AsyncOperation = std::function<T()>;
    using Callback = std::function<void(T)>;

    AsyncExecutor(ThreadPool& threadPool, CallbackDispatcher& dispatcher)
        : m_threadPool(threadPool), m_dispatcher(dispatcher) {}

    void start(AsyncOperation operation, Callback callback) {

        m_threadPool.enqueue([this, op = std::move(operation), cb = std::move(callback)]() mutable {
            try {
                T result = op();
                m_dispatcher.post([cb = std::move(cb), result]() mutable {
                    try {
                        cb(result);
                    } catch (const std::exception& e) {
                        // Handle callback exception
                        std::cerr << "Callback exception: " << e.what() << std::endl;
                    }
                });
            } catch (const std::exception& e) {
                // Handle operation exception
                std::cerr << "Operation exception: " << e.what() << std::endl;
            }
        });
    }

    std::future<T> start(AsyncOperation operation) {
        auto promise = std::make_shared<std::promise<T>>();
        auto future = promise->get_future();

        m_threadPool.enqueue([op = std::move(operation), promise]() mutable {
            try {
                T result = op();
                promise->set_value(result);
            } catch (...) {
                promise->set_exception(std::current_exception());
            }
        });

        return future;
    }

private:
    ThreadPool& m_threadPool;
    CallbackDispatcher& m_dispatcher;
};


class VoidAsyncExecutor {
public:
    using VoidAsyncOp = std::function<void()>;
    using VoidCallback = std::function<void()>;

    VoidAsyncExecutor(ThreadPool& threadPool, CallbackDispatcher& dispatcher)
        : m_threadPool(threadPool), m_dispatcher(dispatcher) {}

    void start(VoidAsyncOp operation, VoidCallback callback) const {
        m_threadPool.enqueue([this, op = std::move(operation), cb = std::move(callback)]() mutable {
            try {
                op();
                m_dispatcher.post([cb = std::move(cb)]() mutable {
                    try {
                        cb();
                    } catch (const std::exception& e) {
                        // Handle callback exception
                        std::cerr << "Callback exception: " << e.what() << std::endl;
                    }
                });
            } catch (const std::exception& e) {
                // Handle operation exception
                std::cerr << "Operation exception: " << e.what() << std::endl;
            }
        });
    }

    std::future<void> start(VoidAsyncOp operation)
    {
        auto promise = std::make_shared<std::promise<void>>();
        auto future = promise->get_future();

        m_threadPool.enqueue([op = std::move(operation), promise]() mutable {
            try {
                op();
                promise->set_value();
            } catch (...) {
                promise->set_exception(std::current_exception());
            }
        });

        return future;
    }

private:
    ThreadPool& m_threadPool;
    CallbackDispatcher& m_dispatcher;
};
</file>

<file path="CallbackDispatcher.h" lines="63" modified="2024-09-15 20:58:38">
//
// Created by maxim on 15.09.2024.
//
#pragma once
#include <mutex>
#include <queue>
#include <condition_variable>
#include <functional>

class CallbackDispatcher {
public:
    using Task = std::function<void()>;

    // Post a task to the dispatcher
    void post(Task task) {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            m_tasks.push(std::move(task));
        }
        m_condition.notify_one();
    }

    // Execute all pending tasks
    void execute_pending() {
        std::queue<Task> tasks;
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            std::swap(tasks, m_tasks);
        }

        while (!tasks.empty()) {
            tasks.front()();
            tasks.pop();
        }
    }

    // Wait for tasks to be available
    void wait() {
        std::unique_lock<std::mutex> lock(m_mutex);
        if (m_tasks.empty()) {
            m_condition.wait(lock, [this]() { return !m_tasks.empty() || m_stopped; });
        }
    }

    // Stop the dispatcher
    void stop() {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            m_stopped = true;
        }
        m_condition.notify_all();
    }

    bool is_stopped() const {
        return m_stopped;
    }

private:
    std::queue<Task> m_tasks;
    std::mutex m_mutex;
    std::condition_variable m_condition;
    bool m_stopped = false;
};
</file>

<file path="ThreadPool.h" lines="83" modified="2024-09-15 20:05:54">
//
// Created by maxim on 15.09.2024.
//
#pragma once
#include <functional>
#include <thread>
#include <vector>
#include <queue>
#include <condition_variable>
#include <future>
#include <atomic>
class TaskQueue {
public:
    using Task = std::function<void()>;

    void push(Task task) {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            m_tasks.push(std::move(task));
        }
        m_condition.notify_one();
    }

    bool pop(Task& task) {
        std::unique_lock<std::mutex> lock(m_mutex);

        m_condition.wait(lock, [this]() {
            return !m_tasks.empty() || m_stopped;
        });

        if (m_stopped && m_tasks.empty())
            return false;

        task = std::move(m_tasks.front());
        m_tasks.pop();
        return true;
    }

    void stop() {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            m_stopped = true;
        }
        m_condition.notify_all();
    }

private:
    std::queue<Task> m_tasks;
    std::mutex m_mutex;
    std::condition_variable m_condition;
    bool m_stopped = false;
};

class ThreadPool {
public:
    explicit ThreadPool(size_t threadCount = std::thread::hardware_concurrency()) : m_queue(), m_threads(threadCount) {
        for (auto& thread : m_threads) {
            thread = std::thread([this]() {
                TaskQueue::Task task;
                while (m_queue.pop(task)) {
                    task();
                }
            });
        }
    }

    ~ThreadPool() {
        m_queue.stop();
        for (auto& thread : m_threads) {
            if (thread.joinable())
                thread.join();
        }
    }

    template<typename F>
    void enqueue(F&& task) {
        m_queue.push(std::forward<F>(task));
    }

private:
    TaskQueue m_queue;
    std::vector<std::thread> m_threads;
};
</file>

<file path="main.cpp" lines="57" modified="2024-09-15 21:08:02">
#include "AsyncOperation.h"
#include <iostream>

int main() {
    std::cout << "Starting advanced asynchronous system..." << std::endl;

    // Create a thread pool
    ThreadPool threadPool;

    // Create a dispatcher
    CallbackDispatcher dispatcher;

    // Create an AsyncExecutor instance
    AsyncExecutor<int> asyncExecutor(threadPool, dispatcher);

    // Define the completion handler
    auto completionHandler = [](int result) {
        std::cout << "Asynchronous operation completed with result: " << result << std::endl;
    };

    int x = 8;

    // Start multiple asynchronous operations
    for (int i = 0; i < 5; ++i) {
        asyncExecutor.start([x]() {
            std::this_thread::sleep_for(std::chrono::seconds(2));
            return x * x;
        }, completionHandler);
    }

    std::cout << "Asynchronous operations initiated. Main thread is free to continue..." << std::endl;

    std::vector<std::future<int>> futures;
    for (int i = 0; i < 5; ++i) {
        futures.push_back(asyncExecutor.start([x]() {
            std::this_thread::sleep_for(std::chrono::seconds(4));
            return x * x;
        }));
    }

    // Later, collect results
    for (auto& future : futures) {
        int result = future.get(); // Will wait until the result is available
        std::cout << "Future result: " << result << std::endl;
        dispatcher.execute_pending();
    }


    while (!dispatcher.is_stopped()) {
        dispatcher.execute_pending();
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }

    std::cout << "Main thread completed." << std::endl;
    return 0;
}
</file>

